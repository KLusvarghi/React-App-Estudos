{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React from 'react';\n\nconst useFetch = () => {\n  _s();\n\n  const [data, setData] = React.useState(null); // estado para os dados\n\n  const [error, setError] = React.useState(null); // estado para os errors\n\n  const [loading, setLoading] = React.useState(null); // estado para o loadding\n  // fazedno um função de request, para idenpende do momento, oa clicar em um botão, quando o componente montar ele conseguir acessar independente do momento\n  // Para que essa função não seja recriada diversas vezes, eu posso usar o useCallback para isso\n\n  async function request(url, options) {\n    let response;\n    let json;\n\n    try {\n      // para verificar  o erro, utilizamos o try e catch\n      setError(null); // ao renderizar passamos 'null' para que nãoq fique exibindo o erro direto na tela mesmo que o usuário tente novamente fazer esse request\n\n      setLoading(true); // ao iniciar o fetch ele irá aparecer carreganod na tela\n      // passando a url e as opções, para quando se quer fazer um POST, GET, DELETE, etc\n\n      response = await fetch(url, options);\n      json = await response.json();\n    } catch (error) {\n      // caso de erro, ele exibe o que está dentro do catch\n      json = null; // caso caia no catch, ele já passa o valor null, que logo em seguida será passado ao 'setData'\n\n      setError(error);\n    } finally {\n      // e sempre irá executar o finally independente de tudo\n      setData(json); // atribuindo o valor ao setData apenas no 'finally' para que ele não tenha trabalho de atribuir depois passar outro valor caso caia no 'catch,\n      // ao finalizar o loading ele aparece false\n\n      setLoading(false); // setando o valor para 'false' por caonta que no try ele set o valor para 'true' no setLoading e em caso de erro ele não chega a setar o valor para 'false', então de qualuer maneira temos que fazer isso no finally\n\n      return {\n        response,\n        json\n      }; // porem esse3 return não tem acesso ao 'response' e  o 'json' por que esles foram definidos dentro do 'try', para solucionar isso definimos ele fora do escopo\n    }\n  }\n\n  return {\n    data,\n    error,\n    loading,\n    request\n  }; // retornando como objeto por conta que quando eu for utilizar eles, eu terei que desestruturar na ordem correta, já quando eu eretorno como objeto eu só coloco o nome\n};\n\n_s(useFetch, \"pIGb0cL0LVrxpU0GUqNo0IH6dXw=\");\n\nexport default useFetch;","map":{"version":3,"names":["React","useFetch","data","setData","useState","error","setError","loading","setLoading","request","url","options","response","json","fetch"],"sources":["C:/Kaua-Lusvarghi/Cursos-Programação/Código-Estudos/Cursos_Programação/React/React - Origamid/Projeto-react-estudos/appreact/src/useFetch.js"],"sourcesContent":["import React from 'react';\r\n\r\nconst useFetch = () => {\r\n  const [data, setData] = React.useState(null); // estado para os dados\r\n  const [error, setError] = React.useState(null); // estado para os errors\r\n  const [loading, setLoading] = React.useState(null); // estado para o loadding\r\n\r\n  // fazedno um função de request, para idenpende do momento, oa clicar em um botão, quando o componente montar ele conseguir acessar independente do momento\r\n\r\n\r\n  // Para que essa função não seja recriada diversas vezes, eu posso usar o useCallback para isso\r\n  async function request(url, options) {\r\n    let response;\r\n    let json;\r\n    try{ // para verificar  o erro, utilizamos o try e catch\r\n      setError(null) // ao renderizar passamos 'null' para que nãoq fique exibindo o erro direto na tela mesmo que o usuário tente novamente fazer esse request\r\n      setLoading(true) // ao iniciar o fetch ele irá aparecer carreganod na tela\r\n      // passando a url e as opções, para quando se quer fazer um POST, GET, DELETE, etc\r\n      response = await fetch(url, options);\r\n      json = await response.json();\r\n    } catch(error){ // caso de erro, ele exibe o que está dentro do catch\r\n      json = null // caso caia no catch, ele já passa o valor null, que logo em seguida será passado ao 'setData'\r\n      setError(error)\r\n    }finally{ // e sempre irá executar o finally independente de tudo\r\n      setData(json); // atribuindo o valor ao setData apenas no 'finally' para que ele não tenha trabalho de atribuir depois passar outro valor caso caia no 'catch,\r\n\r\n      // ao finalizar o loading ele aparece false\r\n      setLoading(false) // setando o valor para 'false' por caonta que no try ele set o valor para 'true' no setLoading e em caso de erro ele não chega a setar o valor para 'false', então de qualuer maneira temos que fazer isso no finally\r\n      return {response, json} // porem esse3 return não tem acesso ao 'response' e  o 'json' por que esles foram definidos dentro do 'try', para solucionar isso definimos ele fora do escopo\r\n    }\r\n  }\r\n\r\n  return { data, error, loading, request }; // retornando como objeto por conta que quando eu for utilizar eles, eu terei que desestruturar na ordem correta, já quando eu eretorno como objeto eu só coloco o nome\r\n};\r\n\r\nexport default useFetch;\r\n"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;;AAEA,MAAMC,QAAQ,GAAG,MAAM;EAAA;;EACrB,MAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBH,KAAK,CAACI,QAAN,CAAe,IAAf,CAAxB,CADqB,CACyB;;EAC9C,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBN,KAAK,CAACI,QAAN,CAAe,IAAf,CAA1B,CAFqB,CAE2B;;EAChD,MAAM,CAACG,OAAD,EAAUC,UAAV,IAAwBR,KAAK,CAACI,QAAN,CAAe,IAAf,CAA9B,CAHqB,CAG+B;EAEpD;EAGA;;EACA,eAAeK,OAAf,CAAuBC,GAAvB,EAA4BC,OAA5B,EAAqC;IACnC,IAAIC,QAAJ;IACA,IAAIC,IAAJ;;IACA,IAAG;MAAE;MACHP,QAAQ,CAAC,IAAD,CAAR,CADC,CACc;;MACfE,UAAU,CAAC,IAAD,CAAV,CAFC,CAEgB;MACjB;;MACAI,QAAQ,GAAG,MAAME,KAAK,CAACJ,GAAD,EAAMC,OAAN,CAAtB;MACAE,IAAI,GAAG,MAAMD,QAAQ,CAACC,IAAT,EAAb;IACD,CAND,CAME,OAAMR,KAAN,EAAY;MAAE;MACdQ,IAAI,GAAG,IAAP,CADY,CACA;;MACZP,QAAQ,CAACD,KAAD,CAAR;IACD,CATD,SASQ;MAAE;MACRF,OAAO,CAACU,IAAD,CAAP,CADM,CACS;MAEf;;MACAL,UAAU,CAAC,KAAD,CAAV,CAJM,CAIY;;MAClB,OAAO;QAACI,QAAD;QAAWC;MAAX,CAAP,CALM,CAKkB;IACzB;EACF;;EAED,OAAO;IAAEX,IAAF;IAAQG,KAAR;IAAeE,OAAf;IAAwBE;EAAxB,CAAP,CA9BqB,CA8BqB;AAC3C,CA/BD;;GAAMR,Q;;AAiCN,eAAeA,QAAf"},"metadata":{},"sourceType":"module"}
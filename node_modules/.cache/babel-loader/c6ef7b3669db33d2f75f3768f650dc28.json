{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React from 'react'; // uma constante / objeto contendo todas as minha validações\n\nconst types = {\n  cep: {\n    regex: /^\\d{5}-?\\d{3}$/,\n    messege: 'Cep inválido'\n  },\n  email: {\n    regex: /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n    messege: 'Insira um email válido!'\n  }\n};\n/*\r\n  quando for usar o useForm, será passado assim:\r\n  useForm('cep)\r\n  e nós iremos acessar o tipe de validação assim:\r\n  types[type]\r\n  que é a mesmas coisa que types['cep']\r\n*/\n\nconst useForm = type => {\n  _s();\n\n  // sendo passado por parametro um tipo de validação, cep, email, etc\n  const [value, setValue] = React.useState('');\n  const [error, setError] = React.useState(null); // função de validação de CEP\n\n  function validate(value) {\n    // recebendo o valor digitado pelo usuário\n    console.log('O valor de value é: ' + value);\n\n    if (value.length === 0) {\n      setError('Preencha um valor!');\n      return false;\n    } else if (!types[type].regex.test(value)) {\n      setError(types[type].messege);\n      return false;\n    } else {\n      setError(null);\n      return true;\n    }\n  } // fazendo essa função por conta que caso o usuário errar, depois inserir um cep novo correto, a mesagem de erro só irá sair se ele sair do campo, deixando ruim para o uruário\n\n\n  function onChange(_ref) {\n    let {\n      target\n    } = _ref;\n    if (error) validate(target.value); // se caso já existir um erro, ele faz a verificação novamente\n\n    setValue(target.value); // atribuindo o valordigitado pelo usuário ao useVelue\n  }\n\n  return {\n    value,\n    setValue,\n    error,\n    onChange,\n    onBlur: () => validate(value),\n    // assim que eu utilziar o unBlur ele já fará a validação\n    validate: () => validate(value)\n  };\n};\n\n_s(useForm, \"2xVBvVJ4brbuuUPeIt3XLET8CmM=\");\n\nexport default useForm;","map":{"version":3,"names":["React","types","cep","regex","messege","email","useForm","type","value","setValue","useState","error","setError","validate","console","log","length","test","onChange","target","onBlur"],"sources":["C:/Kaua-Lusvarghi/Cursos-Programação/Código-Estudos/Cursos_Programação/React/React - Origamid/Projeto-react-estudos/appreact/src/Hooks/useForm.js"],"sourcesContent":["import React from 'react';\r\n// uma constante / objeto contendo todas as minha validações\r\nconst types = {\r\n  cep: {\r\n    regex: /^\\d{5}-?\\d{3}$/,\r\n    messege: 'Cep inválido'\r\n  },\r\n  email: {\r\n    regex:\r\n    /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\r\n    messege: 'Insira um email válido!'\r\n  },\r\n};\r\n\r\n/*\r\n  quando for usar o useForm, será passado assim:\r\n  useForm('cep)\r\n  e nós iremos acessar o tipe de validação assim:\r\n  types[type]\r\n  que é a mesmas coisa que types['cep']\r\n*/\r\n\r\nconst useForm = (type) => {\r\n  // sendo passado por parametro um tipo de validação, cep, email, etc\r\n  const [value, setValue] = React.useState('');\r\n  const [error, setError] = React.useState(null);\r\n\r\n  // função de validação de CEP\r\n  function validate(value) {\r\n    // recebendo o valor digitado pelo usuário\r\n    console.log('O valor de value é: ' + value);\r\n    if (value.length === 0) {\r\n      setError('Preencha um valor!');\r\n      return false;\r\n    } else if (!types[type].regex.test(value)) {\r\n      setError(types[type].messege);\r\n      return false;\r\n    } else {\r\n      setError(null);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // fazendo essa função por conta que caso o usuário errar, depois inserir um cep novo correto, a mesagem de erro só irá sair se ele sair do campo, deixando ruim para o uruário\r\n  function onChange({ target }) {\r\n    if (error) validate(target.value); // se caso já existir um erro, ele faz a verificação novamente\r\n    setValue(target.value); // atribuindo o valordigitado pelo usuário ao useVelue\r\n  }\r\n\r\n  return {\r\n    value,\r\n    setValue,\r\n    error,\r\n    onChange,\r\n    onBlur: () => validate(value), // assim que eu utilziar o unBlur ele já fará a validação\r\n    validate: () => validate(value),\r\n  };\r\n};\r\n\r\nexport default useForm;\r\n"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CACA;;AACA,MAAMC,KAAK,GAAG;EACZC,GAAG,EAAE;IACHC,KAAK,EAAE,gBADJ;IAEHC,OAAO,EAAE;EAFN,CADO;EAKZC,KAAK,EAAE;IACLF,KAAK,EACL,uJAFK;IAGLC,OAAO,EAAE;EAHJ;AALK,CAAd;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,OAAO,GAAIC,IAAD,IAAU;EAAA;;EACxB;EACA,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBT,KAAK,CAACU,QAAN,CAAe,EAAf,CAA1B;EACA,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBZ,KAAK,CAACU,QAAN,CAAe,IAAf,CAA1B,CAHwB,CAKxB;;EACA,SAASG,QAAT,CAAkBL,KAAlB,EAAyB;IACvB;IACAM,OAAO,CAACC,GAAR,CAAY,yBAAyBP,KAArC;;IACA,IAAIA,KAAK,CAACQ,MAAN,KAAiB,CAArB,EAAwB;MACtBJ,QAAQ,CAAC,oBAAD,CAAR;MACA,OAAO,KAAP;IACD,CAHD,MAGO,IAAI,CAACX,KAAK,CAACM,IAAD,CAAL,CAAYJ,KAAZ,CAAkBc,IAAlB,CAAuBT,KAAvB,CAAL,EAAoC;MACzCI,QAAQ,CAACX,KAAK,CAACM,IAAD,CAAL,CAAYH,OAAb,CAAR;MACA,OAAO,KAAP;IACD,CAHM,MAGA;MACLQ,QAAQ,CAAC,IAAD,CAAR;MACA,OAAO,IAAP;IACD;EACF,CAnBuB,CAqBxB;;;EACA,SAASM,QAAT,OAA8B;IAAA,IAAZ;MAAEC;IAAF,CAAY;IAC5B,IAAIR,KAAJ,EAAWE,QAAQ,CAACM,MAAM,CAACX,KAAR,CAAR,CADiB,CACO;;IACnCC,QAAQ,CAACU,MAAM,CAACX,KAAR,CAAR,CAF4B,CAEJ;EACzB;;EAED,OAAO;IACLA,KADK;IAELC,QAFK;IAGLE,KAHK;IAILO,QAJK;IAKLE,MAAM,EAAE,MAAMP,QAAQ,CAACL,KAAD,CALjB;IAK0B;IAC/BK,QAAQ,EAAE,MAAMA,QAAQ,CAACL,KAAD;EANnB,CAAP;AAQD,CAnCD;;GAAMF,O;;AAqCN,eAAeA,OAAf"},"metadata":{},"sourceType":"module"}
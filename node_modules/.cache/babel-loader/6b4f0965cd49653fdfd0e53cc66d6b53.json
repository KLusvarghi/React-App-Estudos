{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React from 'react'; // uma constante / objeto contendo todas as minha validações\n\nconst types = {\n  cep: {\n    regex: /^\\d{5}-?\\d{3}$/,\n    messege: 'Cep inválido'\n  }\n};\n/*\r\n  quando for usar o useForm, será passado assim:\r\n  useForm('cep)\r\n  e nós iremos acessar o tipe de validação assim:\r\n  types[type]\r\n  que é a mesmas coisa que types['cep']\r\n*/\n\nconst useForm = type => {\n  _s();\n\n  // sendo passado por parametro um tipo de validação, cep, email, etc\n  const [value, setValue] = React.useState('');\n  const [error, setError] = React.useState(null);\n\n  function validate(value) {\n    // recebendo o valor digitado pelo usuário\n    console.log(\"O valor de value é: \" + value);\n\n    if (value.length === 0) {\n      setError('Preencha um valor!');\n      return false;\n    } else if (!types[type].regex.test(value)) {\n      setError(types[type].messege);\n      return false;\n    } else {\n      setError(null);\n      return true;\n    }\n  } // fazendo essa função por conta que caso o usuário errar, depois inserir um cep novo correto, a mesagem de erro só irá sair se ele sair do campo, deixando ruim para o uruário\n\n\n  function onChange(_ref) {\n    let {\n      target\n    } = _ref;\n    if (error) validate(target.value); // se caso já existir um erro, ele faz a verificação novamente\n\n    setValue(target.value);\n    console.log(value);\n  }\n\n  return {\n    value,\n    setValue,\n    error,\n    onChange,\n    onBlur: () => validate(value) // assim que eu utilziar o unBlur ele já fará a validação\n\n  };\n};\n\n_s(useForm, \"2xVBvVJ4brbuuUPeIt3XLET8CmM=\");\n\nexport default useForm;","map":{"version":3,"names":["React","types","cep","regex","messege","useForm","type","value","setValue","useState","error","setError","validate","console","log","length","test","onChange","target","onBlur"],"sources":["C:/Kaua-Lusvarghi/Cursos-Programação/Código-Estudos/Cursos_Programação/React/React - Origamid/Projeto-react-estudos/appreact/src/Hooks/useForm.js"],"sourcesContent":["import React from 'react';\r\n// uma constante / objeto contendo todas as minha validações\r\nconst types = {\r\n  cep: {\r\n    regex: /^\\d{5}-?\\d{3}$/,\r\n    messege: 'Cep inválido'\r\n  }\r\n}\r\n\r\n/*\r\n  quando for usar o useForm, será passado assim:\r\n  useForm('cep)\r\n  e nós iremos acessar o tipe de validação assim:\r\n  types[type]\r\n  que é a mesmas coisa que types['cep']\r\n*/\r\n\r\n\r\nconst useForm = (type) => { // sendo passado por parametro um tipo de validação, cep, email, etc\r\n  const [value, setValue] = React.useState('');\r\n  const [error, setError] = React.useState(null);\r\n\r\n  function validate(value) { // recebendo o valor digitado pelo usuário\r\n    console.log(\"O valor de value é: \" + value)\r\n    if (value.length === 0) {\r\n      setError('Preencha um valor!');\r\n      return false;\r\n    } else if (!types[type].regex.test(value)) {\r\n      setError(types[type].messege);\r\n      return false;\r\n    } else {\r\n      setError(null);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // fazendo essa função por conta que caso o usuário errar, depois inserir um cep novo correto, a mesagem de erro só irá sair se ele sair do campo, deixando ruim para o uruário\r\n  function onChange({target}) {\r\n    if(error) validate(target.value) // se caso já existir um erro, ele faz a verificação novamente\r\n    setValue(target.value)\r\n    console.log(value)\r\n  }\r\n\r\n  return {\r\n    value,\r\n    setValue,\r\n    error,\r\n    onChange,\r\n    onBlur: () => validate(value) // assim que eu utilziar o unBlur ele já fará a validação\r\n  };\r\n};\r\n\r\nexport default useForm;\r\n"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CACA;;AACA,MAAMC,KAAK,GAAG;EACZC,GAAG,EAAE;IACHC,KAAK,EAAE,gBADJ;IAEHC,OAAO,EAAE;EAFN;AADO,CAAd;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAMC,OAAO,GAAIC,IAAD,IAAU;EAAA;;EAAE;EAC1B,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBR,KAAK,CAACS,QAAN,CAAe,EAAf,CAA1B;EACA,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBX,KAAK,CAACS,QAAN,CAAe,IAAf,CAA1B;;EAEA,SAASG,QAAT,CAAkBL,KAAlB,EAAyB;IAAE;IACzBM,OAAO,CAACC,GAAR,CAAY,yBAAyBP,KAArC;;IACA,IAAIA,KAAK,CAACQ,MAAN,KAAiB,CAArB,EAAwB;MACtBJ,QAAQ,CAAC,oBAAD,CAAR;MACA,OAAO,KAAP;IACD,CAHD,MAGO,IAAI,CAACV,KAAK,CAACK,IAAD,CAAL,CAAYH,KAAZ,CAAkBa,IAAlB,CAAuBT,KAAvB,CAAL,EAAoC;MACzCI,QAAQ,CAACV,KAAK,CAACK,IAAD,CAAL,CAAYF,OAAb,CAAR;MACA,OAAO,KAAP;IACD,CAHM,MAGA;MACLO,QAAQ,CAAC,IAAD,CAAR;MACA,OAAO,IAAP;IACD;EACF,CAhBuB,CAkBxB;;;EACA,SAASM,QAAT,OAA4B;IAAA,IAAV;MAACC;IAAD,CAAU;IAC1B,IAAGR,KAAH,EAAUE,QAAQ,CAACM,MAAM,CAACX,KAAR,CAAR,CADgB,CACO;;IACjCC,QAAQ,CAACU,MAAM,CAACX,KAAR,CAAR;IACAM,OAAO,CAACC,GAAR,CAAYP,KAAZ;EACD;;EAED,OAAO;IACLA,KADK;IAELC,QAFK;IAGLE,KAHK;IAILO,QAJK;IAKLE,MAAM,EAAE,MAAMP,QAAQ,CAACL,KAAD,CALjB,CAKyB;;EALzB,CAAP;AAOD,CAhCD;;GAAMF,O;;AAkCN,eAAeA,OAAf"},"metadata":{},"sourceType":"module"}